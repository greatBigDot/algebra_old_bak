<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Algebra.Data.Group</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Algebra.Data.Group.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">algebra-0.1.0.0: Typeclasses and convenience functions for some algebraic structures (laws unenforced).</p></div><div id="content"><div id="module-header"><table class="info"><tr><th valign="top">Copyright</th><td>(c) greatBigDot 2018</td></tr><tr><th>License</th><td>BSD-3-Clause</td></tr><tr><th>Maintainer</th><td>greatBigDot@gmail.com</td></tr><tr><th>Stability</th><td>experimental</td></tr><tr><th>Safe Haskell</th><td>Safe</td></tr><tr><th>Language</th><td>Haskell2010</td></tr><tr><th>Extensions</th><td><ul class="extension-list"><li>MonoLocalBinds</li><li>TypeInType</li><li>GADTs</li><li>GADTSyntax</li><li>PolyKinds</li><li>DataKinds</li><li>TypeSynonymInstances</li><li>FlexibleInstances</li><li>KindSignatures</li></ul></td></tr></table><p class="caption">Algebra.Data.Group</p></div><div id="description"><p class="caption">Description</p><div class="doc"><p>This module defines a mathematical &quot;group&quot; as a Haskell typeclass. (See
 module <a href="Algebra.html">Algebra</a> for an overview of algebraic structures. See typeclass
 <code><a href="Algebra-Data-Group.html#t:Group" title="Algebra.Data.Group">Group</a></code> for discussion about implementation.) Groups are defined by a single
 set \(G\) and an associative unital invertible binary operation \(*\) defined
 over it. Alternatively, one can view a group as consisting of said set, an
 associative binary operation \(*\), a nullary operation (i.e., an element of
 the set) \(1\), and a unary operation \((-)^{-1}\) over
 it, such that \(1\) is an identity of \(*\) and
 \((-)^{-1}\) inverts \(*\). These perspectives are
 equivalent; to prove equivalence, however, you must first show that the first
 definition implies the uniqueness of the identity and the inversion operator.
 (Proving this is left as an exercise to the reader.) The latter view, typical
 in universal algebra, will be much more convenient to use in Haskell; as
 mentioned in the package overview, the structures' axioms cannot be verified,
 and so treating the identity and inversion operators as part of a group's
 definition allows us to verify more of the mathematical details.</p><p>To speak more formally, a <strong>group</strong> is a 4-tuple
 \(\mathscr{G} = (G : \mathscr{V},* : G^2 \to G, 1 : G, (-)^{-1} : G \to G)\)
 satisfying the following axioms (all variables are implcitly universally
 quantified over \(G\)):</p><ul><li><em>Associativity:</em> \(\quad\) \((x*y)*z = x*(y*z)\)</li><li><em>Identity:</em> \(\quad\) \(x*1 = 1*x = x\)</li><li><em>Inverses:</em> \(\quad\) \(x*(x^{-1}) = (x^{-1})*x = 1\)</li></ul><p>Groups are useful for modelling <em>symmetries</em>. That is, you have some
 object---say, a geometrical figure---that you can transform in various ways
 that leave the object unchanged. For example, if you have a square, you can
 rotate it \(90^{\circ}\), \(180^{\circ}\), \(270^{\circ}\), or \(0^{\circ}\)
 and it looks the same as it did before. You can view these
 &quot;symmetries&quot;---that is, transformations that preserve the salient features of
 the object---as forming a group, with composition as the group operation.
 Indeed, any two symmetric transforms applied one after another yield another
 symmetry; applying one symmetry, and then (applying a second, then a third)
 is exactly equivalent to (applying one symmetry, and then a second), and then
 applying a third; there is an identity symmetry that leaves other symmetries
 unchanged upon composition (the identity function (or if you prefer, rotation
 by \(0^{\circ}\))); and every symmetry has a corresponding symmetry that
 undoes it. The awesome thing is that these observations don't merely apply
 the rotations of a square---if you have <em>any</em> set of ways to transform <em>any</em>
 mathematical object, such that you include a &quot;do-nothing&quot; transformation and
 every transformation has a corresponding transformation done &quot;in reverse&quot;---
 well, then you have a group! (Assoicativity if guaranteed because function
 composition is of course always associative!) Interestingly, the converse of
 this idea holds; every group is a subgroup of some symmetric group. As for
 applications, group theory is central to modern particle physics due to the
 various symmetric properties the universe exhibits at that scale (sorry for
 being so vague, but it's too complicated to go into further detail here).</p><p>Groups probably have the highest product of simplicity and interesting-ness,
 for some values of those terms. They provide a natural foudnation for
 defining more &quot;structured&quot; structures, such as rings.</p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><span class="keyword">class</span> <a href="../base-4.11.0.0/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> g =&gt; <a href="#t:Group">Group</a> g <span class="keyword">where</span><ul class="subs"></ul></li><li class="src short"><a href="#v:-94-">(^)</a> :: <a href="Algebra-Data-Group.html#t:Group" title="Algebra.Data.Group">Group</a> grp =&gt; grp -&gt; <a href="../base-4.11.0.0/Prelude.html#t:Integer" title="Prelude">Integer</a> -&gt; grp</li><li class="src short"><a href="#v:-47--47-">(//)</a> :: <a href="Algebra-Data-Group.html#t:Group" title="Algebra.Data.Group">Group</a> grp =&gt; grp -&gt; grp -&gt; grp</li><li class="src short"><a href="#v:-92--92-">(\\)</a> :: <a href="Algebra-Data-Group.html#t:Group" title="Algebra.Data.Group">Group</a> grp =&gt; grp -&gt; grp -&gt; grp</li><li class="src short"><a href="#v:order">order</a> :: <a href="Algebra-Data-Group.html#t:Group" title="Algebra.Data.Group">Group</a> grp =&gt; grp -&gt; <a href="../base-4.11.0.0/Prelude.html#t:Integer" title="Prelude">Integer</a></li></ul></details></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><span class="keyword">class</span> <a href="../base-4.11.0.0/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> g =&gt; <a id="t:Group" class="def">Group</a> g <span class="keyword">where</span> <a href="src/Algebra.Data.Group.html#Group" class="link">Source</a> <a href="#t:Group" class="selflink">#</a></p><div class="doc"><p>A <code>Group</code> is a type <code>G</code> combined with an instance declaration for the <code><a href="Algebra-Data-Group.html#t:Group" title="Algebra.Data.Group">Group</a></code>
 typeclass, whose minimally complete (and in fact only possible) definition is
 of <code>(((*) :: G -&gt; G -&gt; G), ((id) :: G), (inv :: G -&gt; G))</code> that satisfies the
 following unchecked properties:</p><pre>(x * y) * z == x * (y * z)</pre><pre>(x * id == x) &amp;&amp; (id * x == x)</pre><pre>(x * inv x == x) &amp;&amp; (inv x * x == x)</pre><p>Note that the same type can be a group in multiple ways. This is a bit
 annoying in Haskell, as it necessitates the use of <code>type</code> wrappers to
 implement a class in different ways in the same scope.</p></div><div class="subs minimal"><p class="caption">Minimal complete definition</p><p class="src"><a href="Algebra-Data-Group.html#v:-42-" title="Algebra.Data.Group">(*)</a>, <a href="Algebra-Data-Group.html#v:id" title="Algebra.Data.Group">id</a>, <a href="Algebra-Data-Group.html#v:inv" title="Algebra.Data.Group">inv</a></p></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a id="v:-42-" class="def">(*)</a> :: g -&gt; g -&gt; g <a href="src/Algebra.Data.Group.html#%2A" class="link">Source</a> <a href="#v:-42-" class="selflink">#</a></p><p class="src"><a id="v:id" class="def">id</a> :: g <a href="src/Algebra.Data.Group.html#id" class="link">Source</a> <a href="#v:id" class="selflink">#</a></p><p class="src"><a id="v:inv" class="def">inv</a> :: g -&gt; g <a href="src/Algebra.Data.Group.html#inv" class="link">Source</a> <a href="#v:inv" class="selflink">#</a></p></div><div class="subs instances"><details id="i:Group" open="open"><summary>Instances</summary><table><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:Group:Group:1"></span> <a href="Algebra-Data-Group.html#t:Group" title="Algebra.Data.Group">Group</a> <a href="../base-4.11.0.0/Prelude.html#t:Integer" title="Prelude">Integer</a></span> <a href="src/Algebra.Data.Group.html#line-140" class="link">Source</a> <a href="#t:Group" class="selflink">#</a></td><td class="doc"><p>The integers form a group under addition, with \(0\) as the identity. (The
 notation is quite unfortunate, especially since the integers don't form a
 group under multiplication!)</p></td></tr><tr><td colspan="2"><details id="i:ic:Group:Group:1"><summary class="hide-when-js-enabled">Instance details</summary><div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:-42-">(*)</a> :: <a href="../base-4.11.0.0/Prelude.html#t:Integer" title="Prelude">Integer</a> -&gt; <a href="../base-4.11.0.0/Prelude.html#t:Integer" title="Prelude">Integer</a> -&gt; <a href="../base-4.11.0.0/Prelude.html#t:Integer" title="Prelude">Integer</a> <a href="src/Algebra.Data.Group.html#%2A" class="link">Source</a> <a href="#v:-42-" class="selflink">#</a></p><p class="src"><a href="#v:id">id</a> :: <a href="../base-4.11.0.0/Prelude.html#t:Integer" title="Prelude">Integer</a> <a href="src/Algebra.Data.Group.html#id" class="link">Source</a> <a href="#v:id" class="selflink">#</a></p><p class="src"><a href="#v:inv">inv</a> :: <a href="../base-4.11.0.0/Prelude.html#t:Integer" title="Prelude">Integer</a> -&gt; <a href="../base-4.11.0.0/Prelude.html#t:Integer" title="Prelude">Integer</a> <a href="src/Algebra.Data.Group.html#inv" class="link">Source</a> <a href="#v:inv" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:Group:Group:2"></span> <a href="Algebra-Data-Group.html#t:Group" title="Algebra.Data.Group">Group</a> <a href="../base-4.11.0.0/Prelude.html#t:Rational" title="Prelude">Rational</a></span> <a href="src/Algebra.Data.Group.html#line-147" class="link">Source</a> <a href="#t:Group" class="selflink">#</a></td><td class="doc"><p>The rationals form a group under addition the same way the integers do.
 Again, the notation is horrid--sorry!</p></td></tr><tr><td colspan="2"><details id="i:ic:Group:Group:2"><summary class="hide-when-js-enabled">Instance details</summary><div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:-42-">(*)</a> :: <a href="../base-4.11.0.0/Prelude.html#t:Rational" title="Prelude">Rational</a> -&gt; <a href="../base-4.11.0.0/Prelude.html#t:Rational" title="Prelude">Rational</a> -&gt; <a href="../base-4.11.0.0/Prelude.html#t:Rational" title="Prelude">Rational</a> <a href="src/Algebra.Data.Group.html#%2A" class="link">Source</a> <a href="#v:-42-" class="selflink">#</a></p><p class="src"><a href="#v:id">id</a> :: <a href="../base-4.11.0.0/Prelude.html#t:Rational" title="Prelude">Rational</a> <a href="src/Algebra.Data.Group.html#id" class="link">Source</a> <a href="#v:id" class="selflink">#</a></p><p class="src"><a href="#v:inv">inv</a> :: <a href="../base-4.11.0.0/Prelude.html#t:Rational" title="Prelude">Rational</a> -&gt; <a href="../base-4.11.0.0/Prelude.html#t:Rational" title="Prelude">Rational</a> <a href="src/Algebra.Data.Group.html#inv" class="link">Source</a> <a href="#v:inv" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:Group:Group:3"></span> (<a href="Algebra-Data-Group.html#t:Group" title="Algebra.Data.Group">Group</a> g, <a href="Algebra-Data-Group.html#t:Group" title="Algebra.Data.Group">Group</a> h) =&gt; <a href="Algebra-Data-Group.html#t:Group" title="Algebra.Data.Group">Group</a> (g, h)</span> <a href="src/Algebra.Data.Group.html#line-132" class="link">Source</a> <a href="#t:Group" class="selflink">#</a></td><td class="doc"><p>For any two groups \(G\) and \(H\), there is a group \(G \times H\) defined
 in the obvious way.</p></td></tr><tr><td colspan="2"><details id="i:ic:Group:Group:3"><summary class="hide-when-js-enabled">Instance details</summary><div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:-42-">(*)</a> :: (g, h) -&gt; (g, h) -&gt; (g, h) <a href="src/Algebra.Data.Group.html#%2A" class="link">Source</a> <a href="#v:-42-" class="selflink">#</a></p><p class="src"><a href="#v:id">id</a> :: (g, h) <a href="src/Algebra.Data.Group.html#id" class="link">Source</a> <a href="#v:id" class="selflink">#</a></p><p class="src"><a href="#v:inv">inv</a> :: (g, h) -&gt; (g, h) <a href="src/Algebra.Data.Group.html#inv" class="link">Source</a> <a href="#v:inv" class="selflink">#</a></p></div></details></td></tr></table></details></div></div><div class="top"><p class="src"><a id="v:-94-" class="def">(^)</a> :: <a href="Algebra-Data-Group.html#t:Group" title="Algebra.Data.Group">Group</a> grp =&gt; grp -&gt; <a href="../base-4.11.0.0/Prelude.html#t:Integer" title="Prelude">Integer</a> -&gt; grp <a href="src/Algebra.Data.Group.html#%5E" class="link">Source</a> <a href="#v:-94-" class="selflink">#</a></p><div class="doc"><p>Exponentiation, or repeated application of the group function <code>(</code><code><a href="Algebra-Data-Group.html#v:-42-" title="Algebra.Data.Group">*</a></code><code>)</code>. Note
 that this is <em>not</em> a binary operation over a <code><a href="Algebra-Data-Group.html#t:Group" title="Algebra.Data.Group">Group</a></code>; the first argument is a
 member of the group, but the second is just an integer, specifying how many
 times to repeat the operation. Raising to the zeroth power yields identity;
 raising to a negative power is the corresponding positive power of the
 inverse.</p></div></div><div class="top"><p class="src"><a id="v:-47--47-" class="def">(//)</a> :: <a href="Algebra-Data-Group.html#t:Group" title="Algebra.Data.Group">Group</a> grp =&gt; grp -&gt; grp -&gt; grp <a href="src/Algebra.Data.Group.html#%2F%2F" class="link">Source</a> <a href="#v:-47--47-" class="selflink">#</a></p><div class="doc"><p>Right group division. The first argument is multiplied on the right by the
 inverse of the second argument. Because <code>(</code><code><a href="Algebra-Data-Group.html#v:-42-" title="Algebra.Data.Group">*</a></code><code>)</code> is not necessarily
 commutative, this may differ from left division, <code>(</code><code><a href="Algebra-Data-Group.html#v:-92--92-" title="Algebra.Data.Group">\\</a></code><code>)</code>. For example,
 <code>h*g//g == h</code>, but <code>h*g//h</code> is not necessarily <code>g</code>.</p></div></div><div class="top"><p class="src"><a id="v:-92--92-" class="def">(\\)</a> :: <a href="Algebra-Data-Group.html#t:Group" title="Algebra.Data.Group">Group</a> grp =&gt; grp -&gt; grp -&gt; grp <a href="src/Algebra.Data.Group.html#%5C%5C" class="link">Source</a> <a href="#v:-92--92-" class="selflink">#</a></p><div class="doc"><p>Left group division. The first argument is multiplied on the left by the
 inverse of the second argument. Because <code>(</code><code><a href="Algebra-Data-Group.html#v:-42-" title="Algebra.Data.Group">*</a></code><code>)</code> is not necessarily
 commutative, this may differ from right division, <code>(</code><code><a href="Algebra-Data-Group.html#v:-47--47-" title="Algebra.Data.Group">//</a></code><code>)</code>. For example,
 <code>h*g\\h == g</code>, but <code>h*g\\g</code> is not necessarily <code>h</code>.</p></div></div><div class="top"><p class="src"><a id="v:order" class="def">order</a> :: <a href="Algebra-Data-Group.html#t:Group" title="Algebra.Data.Group">Group</a> grp =&gt; grp -&gt; <a href="../base-4.11.0.0/Prelude.html#t:Integer" title="Prelude">Integer</a> <a href="src/Algebra.Data.Group.html#order" class="link">Source</a> <a href="#v:order" class="selflink">#</a></p><div class="doc"><p>The <code><a href="Algebra-Data-Group.html#v:order" title="Algebra.Data.Group">order</a></code> of an element of a group is the smallest positive integer such that
 raising the group element to that power (see <code>(</code><code><a href="Algebra-Data-Group.html#v:-94-" title="Algebra.Data.Group">^</a></code><code>)</code>) yields the identity,
 <code><a href="Algebra-Data-Group.html#v:id" title="Algebra.Data.Group">id</a></code>---or positive infinity if no such element exists. The latter case
 implies that this function may be (and in fact often is) non-terminating. In
 finite groups (groups with finitely many elements), however, it is a useful
 construct; the order of any element in a fintie group is finite.</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.19.0</p></div></body></html>