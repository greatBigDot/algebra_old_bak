<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Algebra</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Algebra.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">algebra-0.0.1.0: Typeclasses and convenience functions for some algebraic structures (laws unenforced).</p></div><div id="content"><div id="module-header"><table class="info"><tr><th valign="top">Copyright</th><td>(c) greatBigDot 2018</td></tr><tr><th>License</th><td>BSD-3-Clause</td></tr><tr><th>Maintainer</th><td>greatBigDot@gmail.com</td></tr><tr><th>Stability</th><td>experimental</td></tr><tr><th>Safe Haskell</th><td>Safe</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Algebra</p></div><div id="description"><p class="caption">Description</p><div class="doc"><p>This package provides a basic represntation of some common algebraic
 structures (groups, rings, fields, vector spaces, etc.) as Haskell
 typeclasses. Their laws are currently unenforced. (Though, once Haskell
 upgrades its type system to allow dependent typing, that will hopefully
 change!) Till then, this'll do.</p><p>Mathematically, the idea of an algebraic structure is quite simple. Consider
 (a) the set of integers \(\mathbb{Z}\), (b) two of the most basic functions
 on it, \(+ : \mathbb{Z}^2 \to \mathbb{Z} \) and
 \(\cdot : \mathbb{Z}^2 \to \mathbb{Z}\), and (c) two unique elements of it,
 \(0\) and \(1\). There are various obvious properties that universally hold;
 e.g.:</p><ul><li>\(x+(y+z) = (x+y)+z\), and \(x\cdot (y\cdot z) = (x\cdot y)\cdot z\).
 \(\qquad\) [<em>Associativity</em>]</li><li>\(x+y = y+x\), and \(x\cdot y = y\cdot x\) \(\qquad\) [<em>Commutativity</em>]</li><li>\(x+0 = x\cdot 1 = x\) \(\qquad\) [<em>Identities</em>]</li><li>\(\exists y \in \mathbb{Z} [ x+y = 0 ]\) \(\qquad\) [<em>Additive inverse</em>]</li><li>\(x\cdot (y+z) = x\cdot y + x\cdot z\) \(\qquad\) [<em>Distributivity</em>]</li></ul><p>(Unquantified variables are implicitly quantified over the domain of
 discourse, \(\mathbb{Z}\).) There are various things to note. Plenty of
 other sets satisfy these laws; for example, the rational numbers, or the
 real numbers, or the complex numbers. Note also that, say, the irrational
 numbers do <em>not</em> satisfy these properties; \(\pi + (1-\pi)\) is rational, and
 so \(+\) isn't even a binary function over the irrationals! Finally, note
 the asymmetry in the fourth law, an asymmetry not present in the others.
 This is necessary, as the following does <em>not</em> hold:</p><ul><li>\(\exists y \in \mathbb{Z} [ x\cdot y = 1 ]\) \(\qquad\)
 [<em>Multiplicative inverse</em>]</li></ul><p>While \(2\), for example, <em>does</em> have a multiplicative inverse among the
 <em>rationals</em>, it doesn't when we restrict our attention to the integers. (In
 fact, not even the rational numbers satisfy the above law, because \(0\)
 does not have a multiplicative inverse. After modifying the law to account
 for that special case, however, the rationals do satisfy it, while the
 integers still don't.)</p><p>So, was the point of all this? All we did was consider some numbers that
 everyone is familiar with and mention some elementary properties of them.
 How does that lead to any interesting mathematical questions? Well, the key
 idea, the crucial motivating question of abstract algebra, is the following:</p><p><strong><em>What happens when we go in the other direction?</em></strong></p><p>That is, what happens when we <em>start</em> with a list of properties, then ask
 what sorts of things satisfy it? The answers to this question are more
 diverse than you may expect. For example, in addition to the integers and
 its extensions, other more esoteric sets satisfy the above laws. E.g., the
 set of integers modulo five,
 \(\mathbb{Z}_5 = \left\{\overline{0}, \overline{1}, \overline{2}, \overline{3}, \overline{4}\right\}\).
 In this set, to calculate the &quot;sum&quot; of two elements, we calculate their usual
 sum, then take that modulo 5 (that is, the remainder when dividing by 5; the
 modulo operation is essentially a generalization of the concept of even and
 odd numbers to divisibilities other than by 2); similarly with the product.
 Thus, for example, \(\overline{4} + \overline{3} = \overline{2}\). A similar
 line of reasoning indicates that additive inverses exist---in fact, so do
 multiplicative inverses, at least for non-&#8203;\(0\) elements! Observe:</p><ul><li>\(\overline{1} \cdot \overline{1} = \overline{1}\)</li><li>\(\overline{2} \cdot \overline{3} = \overline{1}\)</li><li>\(\overline{3} \cdot \overline{2} = \overline{1}\)</li><li>\(\overline{4} \cdot \overline{4} = \overline{1}\)</li></ul><p>However, if we look at the integers modulo 6 \(\left(\mathbb{Z}_6\right)\), we
 find that multiplicative inverses do <em>not</em> always exist; only
 \(\overline{1}\) and \(\overline{-1} = \overline{5}\) are invertible. (Try
 it!) In fact, the integers modulo \(n\), \(\mathbb{Z}_n\), satisfy the
 weakened (i.e., ignoring \(0\)) multiplicative inverse law if and only if
 \(n\) is prime.</p><p>These do not exhaust the possibilities---not even close!---but it should be
 enough to give a taste of what abstract algebra is all about. You start with
 some set with defined operations (a pairing known as a &quot;structure&quot;) that you
 are familiar with, you distill that structure down to its most basic and
 fundamental properties, and then you look at what sorts of things satisfy
 those properties and what those properties alone entail. This allows you to
 generalize familiar structures to more abstract ideas---the original
 motivating structure becomes just a special case of a more general property,
 and seemingly disparate things suddenly become two special cases of a more
 general idea.</p><p>The laws I gave above define a ring; that is, any set (with the two defined
 binary operations over it, as well as the two distinguished elements)
 satisfying the above list of properties is known as a <strong>ring</strong>. The laws are
 called the <strong>ring axioms</strong>. <strong>Ring theory</strong> is the branch of math studying
 rings and how they relate to each other and to other parts of math. Rings
 are not the only algebraic structure; there are many, many more, and this
 package defines a few of the more important ones as Haskell typeclasses, as
 well as some instances of types as members of that typeclass. Each module
 contains in its documentation an overview of that algebraic structure and
 some interesting properties of them that make them worth studying.</p><p>Sadly, the laws are not yet enforced (as is typical with Haskell
 typeclasses); only the &quot;signature&quot; of the structures are (the set(s), the
 operation(s) defined over it/them, and the types of all objects involved).</p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><span class="keyword">class</span> <a href="../base-4.11.0.0/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> g =&gt; <a href="#t:Group">Group</a> g <span class="keyword">where</span><ul class="subs"></ul></li><li class="src short"><a href="#v:-94-">(^)</a> :: <a href="Algebra.html#t:Group" title="Algebra">Group</a> grp =&gt; grp -&gt; <a href="../base-4.11.0.0/Prelude.html#t:Integer" title="Prelude">Integer</a> -&gt; grp</li><li class="src short"><a href="#v:order">order</a> :: <a href="Algebra.html#t:Group" title="Algebra">Group</a> grp =&gt; grp -&gt; <a href="../base-4.11.0.0/Prelude.html#t:Integer" title="Prelude">Integer</a></li></ul></details></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><span class="keyword">class</span> <a href="../base-4.11.0.0/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> g =&gt; <a id="t:Group" class="def">Group</a> g <span class="keyword">where</span> <a href="src/Algebra.Data.Group.html#Group" class="link">Source</a> <a href="#t:Group" class="selflink">#</a></p><div class="doc"><p>A <code>Group</code> is a type <code>G</code> combined with an instance declaration for the <code><a href="Algebra.html#t:Group" title="Algebra">Group</a></code>
 typeclass, whose minimally complete (and in fact only possible) definition is
 of <code>(((*) :: G -&gt; G -&gt; G), ((id) :: G), (inv :: G -&gt; G))</code> that satisfies the
 following unchecked properties:</p><pre>(x * y) * z == x * (y * z)</pre><pre>(x * id == x) &amp;&amp; (id * x == x)</pre><pre>(x * inv x == x) &amp;&amp; (inv x * x == x)</pre><p>Note that the same type can be a group in multiple ways. This is a bit
 annoying in Haskell, as it necessitates the use of <code>type</code> wrappers to
 implement a class in different ways in the same scope.</p></div><div class="subs minimal"><p class="caption">Minimal complete definition</p><p class="src"><a href="Algebra.html#v:-42-" title="Algebra">(*)</a>, <a href="Algebra.html#v:id" title="Algebra">id</a>, <a href="Algebra.html#v:inv" title="Algebra">inv</a></p></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a id="v:-42-" class="def">(*)</a> :: g -&gt; g -&gt; g <a href="src/Algebra.Data.Group.html#%2A" class="link">Source</a> <a href="#v:-42-" class="selflink">#</a></p><p class="src"><a id="v:id" class="def">id</a> :: g <a href="src/Algebra.Data.Group.html#id" class="link">Source</a> <a href="#v:id" class="selflink">#</a></p><p class="src"><a id="v:inv" class="def">inv</a> :: g -&gt; g <a href="src/Algebra.Data.Group.html#inv" class="link">Source</a> <a href="#v:inv" class="selflink">#</a></p></div><div class="subs instances"><details id="i:Group" open="open"><summary>Instances</summary><table><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:Group:Group:1"></span> <a href="Algebra.html#t:Group" title="Algebra">Group</a> <a href="../base-4.11.0.0/Prelude.html#t:Integer" title="Prelude">Integer</a></span> <a href="src/Algebra.Data.Group.html#line-121" class="link">Source</a> <a href="#t:Group" class="selflink">#</a></td><td class="doc"><p>The integers form a group under addition, with \(0\) as the identity. (The
 notation is quite unfortunate, especially since the integers don't forma
 group under multiplication!)</p></td></tr><tr><td colspan="2"><details id="i:ic:Group:Group:1"><summary class="hide-when-js-enabled">Instance details</summary><div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:-42-">(*)</a> :: <a href="../base-4.11.0.0/Prelude.html#t:Integer" title="Prelude">Integer</a> -&gt; <a href="../base-4.11.0.0/Prelude.html#t:Integer" title="Prelude">Integer</a> -&gt; <a href="../base-4.11.0.0/Prelude.html#t:Integer" title="Prelude">Integer</a> <a href="src/Algebra.Data.Group.html#%2A" class="link">Source</a> <a href="#v:-42-" class="selflink">#</a></p><p class="src"><a href="#v:id">id</a> :: <a href="../base-4.11.0.0/Prelude.html#t:Integer" title="Prelude">Integer</a> <a href="src/Algebra.Data.Group.html#id" class="link">Source</a> <a href="#v:id" class="selflink">#</a></p><p class="src"><a href="#v:inv">inv</a> :: <a href="../base-4.11.0.0/Prelude.html#t:Integer" title="Prelude">Integer</a> -&gt; <a href="../base-4.11.0.0/Prelude.html#t:Integer" title="Prelude">Integer</a> <a href="src/Algebra.Data.Group.html#inv" class="link">Source</a> <a href="#v:inv" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:Group:Group:2"></span> (<a href="Algebra.html#t:Group" title="Algebra">Group</a> g, <a href="Algebra.html#t:Group" title="Algebra">Group</a> h) =&gt; <a href="Algebra.html#t:Group" title="Algebra">Group</a> (g, h)</span> <a href="src/Algebra.Data.Group.html#line-113" class="link">Source</a> <a href="#t:Group" class="selflink">#</a></td><td class="doc"><p>For any two groups \(G\) and \(H\), there is a group \(G \times H\) defined
 in the obvious way.</p></td></tr><tr><td colspan="2"><details id="i:ic:Group:Group:2"><summary class="hide-when-js-enabled">Instance details</summary><div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:-42-">(*)</a> :: (g, h) -&gt; (g, h) -&gt; (g, h) <a href="src/Algebra.Data.Group.html#%2A" class="link">Source</a> <a href="#v:-42-" class="selflink">#</a></p><p class="src"><a href="#v:id">id</a> :: (g, h) <a href="src/Algebra.Data.Group.html#id" class="link">Source</a> <a href="#v:id" class="selflink">#</a></p><p class="src"><a href="#v:inv">inv</a> :: (g, h) -&gt; (g, h) <a href="src/Algebra.Data.Group.html#inv" class="link">Source</a> <a href="#v:inv" class="selflink">#</a></p></div></details></td></tr></table></details></div></div><div class="top"><p class="src"><a id="v:-94-" class="def">(^)</a> :: <a href="Algebra.html#t:Group" title="Algebra">Group</a> grp =&gt; grp -&gt; <a href="../base-4.11.0.0/Prelude.html#t:Integer" title="Prelude">Integer</a> -&gt; grp <a href="src/Algebra.Data.Group.html#%5E" class="link">Source</a> <a href="#v:-94-" class="selflink">#</a></p><div class="doc"><p>Exponentiation, or repeated application of the group function &quot;(*)&quot;. Note
 that this is <em>not</em> a binary operation over a <code><a href="Algebra.html#t:Group" title="Algebra">Group</a></code>; the first argument is a
 member of the group, but the second is just an integer, specifying how many
 times to repeat the operation. Raising to the zeroth power yields identity;
 raising to a negative power is the corresponding positive power of the
 inverse.</p></div></div><div class="top"><p class="src"><a id="v:order" class="def">order</a> :: <a href="Algebra.html#t:Group" title="Algebra">Group</a> grp =&gt; grp -&gt; <a href="../base-4.11.0.0/Prelude.html#t:Integer" title="Prelude">Integer</a> <a href="src/Algebra.Data.Group.html#order" class="link">Source</a> <a href="#v:order" class="selflink">#</a></p><div class="doc"><p>The <code><a href="Algebra.html#v:order" title="Algebra">order</a></code> of an element of a group is the smallest positive integer such that
 raising the group element to that power (see '(^)') yields the identity,
 <code><a href="Algebra.html#v:id" title="Algebra">id</a></code>---or positive infinity if no such element exists. The latter case
 implies that this function may be (and in fact often is) non-terminating. In
 finite groups (groups with finitely many elements), however, it is a useful
 construct; the order of any element in a fintie group is finite.</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.19.0</p></div></body></html>