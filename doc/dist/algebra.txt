-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Typeclasses and convenience functions for some algebraic structures (laws unenforced).
--   
--   This package provides a basic represntation of some common algebraic
--   structures (groups, rings, fields, vector spaces, etc.) as Haskell
--   typeclasses. Their laws are currently unenforced. (Though, once
--   Haskell upgrades its type system to allow dependent typing, that will
--   hopefully change!) Till then, this'll do.
--   
--   Mathematically, the idea of an algebraic structure is quite simple.
--   Consider (a) the set of integers &lt;math&gt;, (b) two of the most
--   basic functions on it, &lt;math&gt; and &lt;math&gt;, and (c) two
--   unique elements of it, &lt;math&gt; and &lt;math&gt;. There are
--   various obvious properties that universally hold; e.g.:
--   
--   <ul>
--   <li>&lt;math&gt;, and &lt;math&gt;. &lt;math&gt;
--   [<i>Associativity</i>]</li>
--   <li>&lt;math&gt;, and &lt;math&gt; &lt;math&gt;
--   [<i>Commutativity</i>]</li>
--   <li>&lt;math&gt; &lt;math&gt; [<i>Identities</i>]</li>
--   <li>&lt;math&gt; &lt;math&gt; [<i>Additive inverse</i>]</li>
--   <li>&lt;math&gt; &lt;math&gt; [<i>Distributivity</i>]</li>
--   </ul>
--   
--   (Unquantified variables are implicitly quantified over the domain of
--   discourse, &lt;math&gt;.) There are various things to note. Plenty of
--   other sets satisfy these laws; for example, the rational numbers, or
--   the real numbers, or the complex numbers. Note also that, say, the
--   irrational numbers do <i>not</i> satisfy these properties;
--   &lt;math&gt; is rational, and so &lt;math&gt; isn't even a binary
--   function over the irrationals! Finally, note the asymmetry in the
--   fourth law, an asymmetry not present in the others. This is necessary,
--   as the following does <i>not</i> hold:
--   
--   <ul>
--   <li>&lt;math&gt; &lt;math&gt; [<i>Multiplicative inverse</i>]</li>
--   </ul>
--   
--   While &lt;math&gt;, for example, <i>does</i> have a multiplicative
--   inverse among the <i>rationals</i>, it doesn't when we restrict our
--   attention to the integers. (In fact, not even the rational numbers
--   satisfy the above law, because &lt;math&gt; does not have a
--   multiplicative inverse. After modifying the law to account for that
--   special case, however, the rationals do satisfy it, while the integers
--   still don't.)
--   
--   So, was the point of all this? All we did was consider some numbers
--   that everyone is familiar with and mention some elementary properties
--   of them. How does that lead to any interesting mathematical questions?
--   Well, the key idea, the crucial motivating question of abstract
--   algebra, is the following:
--   
--   <b><i>What happens when we go in the other direction?</i></b>
--   
--   That is, what happens when we <i>start</i> with a list of properties,
--   then ask what sorts of things satisfy it? The answers to this question
--   are more diverse than you may expect. For example, in addition to the
--   integers and its extensions, other more esoteric sets satisfy the
--   above laws. E.g., the set of integers modulo five, &lt;math&gt;. In
--   this set, to calculate the "sum" of two elements, we calculate their
--   usual sum, then take that modulo 5 (that is, the remainder when
--   dividing by 5; the modulo operation is essentially a generalization of
--   the concept of even and odd numbers to divisibilities other than by
--   2); similarly with the product. Thus, for example, &lt;math&gt;. A
--   similar line of reasoning indicates that additive inverses exist---in
--   fact, so do multiplicative inverses, at least for non-​&lt;math&gt;
--   elements! Observe:
--   
--   <ul>
--   <li>&lt;math&gt;</li>
--   <li>&lt;math&gt;</li>
--   <li>&lt;math&gt;</li>
--   <li>&lt;math&gt;</li>
--   </ul>
--   
--   However, if we look at the integers modulo 6 &lt;math&gt;, we find
--   that multiplicative inverses do <i>not</i> always exist; only
--   &lt;math&gt; and &lt;math&gt; are invertible. (Try it!) In fact, the
--   integers modulo &lt;math&gt;, &lt;math&gt;, satisfy the weakened
--   (i.e., ignoring &lt;math&gt;) multiplicative inverse law if and only
--   if &lt;math&gt; is prime.
--   
--   These do not exhaust the possibilities---not even close!---but it
--   should be enough to give a taste of what abstract algebra is all
--   about. You start with some set with defined operations (a pairing
--   known as a "structure") that you are familiar with, you distill that
--   structure down to its most basic and fundamental properties, and then
--   you look at what sorts of things satisfy those properties and what
--   those properties alone entail. This allows you to generalize familiar
--   structures to more abstract ideas---the original motivating structure
--   becomes just a special case of a more general property, and seemingly
--   disparate things suddenly become two special cases of a more general
--   idea.
--   
--   The laws I gave above define a ring; that is, any set (with the two
--   defined binary operations over it, as well as the two distinguished
--   elements) satisfying the above list of properties is known as a
--   <b>ring</b>. The laws are called the <b>ring axioms</b>. <b>Ring
--   theory</b> is the branch of math studying rings and how they relate to
--   each other and to other parts of math. Rings are not the only
--   algebraic structure; there are many, many more, and this package
--   defines a few of the more important ones as Haskell typeclasses, as
--   well as some instances of types as members of that typeclass. Each
--   module contains in its documentation an overview of that algebraic
--   structure and some interesting properties of them that make them worth
--   studying.
--   
--   Sadly, the laws are not yet enforced (as is typical with Haskell
--   typeclasses); only the "signature" of the structures are (the set(s),
--   the operation(s) defined over it/them, and the types of all objects
--   involved).
@package algebra
@version 0.0.1.0


-- | This package provides a basic represntation of some common algebraic
--   structures (groups, rings, fields, vector spaces, etc.) as Haskell
--   typeclasses. Their laws are currently unenforced. (Though, once
--   Haskell upgrades its type system to allow dependent typing, that will
--   hopefully change!) Till then, this'll do.
--   
--   Mathematically, the idea of an algebraic structure is quite simple.
--   Consider (a) the set of integers &lt;math&gt;, (b) two of the most
--   basic functions on it, &lt;math&gt; and &lt;math&gt;, and (c) two
--   unique elements of it, &lt;math&gt; and &lt;math&gt;. There are
--   various obvious properties that universally hold; e.g.:
--   
--   <ul>
--   <li>&lt;math&gt;, and &lt;math&gt;. &lt;math&gt;
--   [<i>Associativity</i>]</li>
--   <li>&lt;math&gt;, and &lt;math&gt; &lt;math&gt;
--   [<i>Commutativity</i>]</li>
--   <li>&lt;math&gt; &lt;math&gt; [<i>Identities</i>]</li>
--   <li>&lt;math&gt; &lt;math&gt; [<i>Additive inverse</i>]</li>
--   <li>&lt;math&gt; &lt;math&gt; [<i>Distributivity</i>]</li>
--   </ul>
--   
--   (Unquantified variables are implicitly quantified over the domain of
--   discourse, &lt;math&gt;.) There are various things to note. Plenty of
--   other sets satisfy these laws; for example, the rational numbers, or
--   the real numbers, or the complex numbers. Note also that, say, the
--   irrational numbers do <i>not</i> satisfy these properties;
--   &lt;math&gt; is rational, and so &lt;math&gt; isn't even a binary
--   function over the irrationals! Finally, note the asymmetry in the
--   fourth law, an asymmetry not present in the others. This is necessary,
--   as the following does <i>not</i> hold:
--   
--   <ul>
--   <li>&lt;math&gt; &lt;math&gt; [<i>Multiplicative inverse</i>]</li>
--   </ul>
--   
--   While &lt;math&gt;, for example, <i>does</i> have a multiplicative
--   inverse among the <i>rationals</i>, it doesn't when we restrict our
--   attention to the integers. (In fact, not even the rational numbers
--   satisfy the above law, because &lt;math&gt; does not have a
--   multiplicative inverse. After modifying the law to account for that
--   special case, however, the rationals do satisfy it, while the integers
--   still don't.)
--   
--   So, was the point of all this? All we did was consider some numbers
--   that everyone is familiar with and mention some elementary properties
--   of them. How does that lead to any interesting mathematical questions?
--   Well, the key idea, the crucial motivating question of abstract
--   algebra, is the following:
--   
--   <b><i>What happens when we go in the other direction?</i></b>
--   
--   That is, what happens when we <i>start</i> with a list of properties,
--   then ask what sorts of things satisfy it? The answers to this question
--   are more diverse than you may expect. For example, in addition to the
--   integers and its extensions, other more esoteric sets satisfy the
--   above laws. E.g., the set of integers modulo five, &lt;math&gt;. In
--   this set, to calculate the "sum" of two elements, we calculate their
--   usual sum, then take that modulo 5 (that is, the remainder when
--   dividing by 5; the modulo operation is essentially a generalization of
--   the concept of even and odd numbers to divisibilities other than by
--   2); similarly with the product. Thus, for example, &lt;math&gt;. A
--   similar line of reasoning indicates that additive inverses exist---in
--   fact, so do multiplicative inverses, at least for non-​&lt;math&gt;
--   elements! Observe:
--   
--   <ul>
--   <li>&lt;math&gt;</li>
--   <li>&lt;math&gt;</li>
--   <li>&lt;math&gt;</li>
--   <li>&lt;math&gt;</li>
--   </ul>
--   
--   However, if we look at the integers modulo 6 &lt;math&gt;, we find
--   that multiplicative inverses do <i>not</i> always exist; only
--   &lt;math&gt; and &lt;math&gt; are invertible. (Try it!) In fact, the
--   integers modulo &lt;math&gt;, &lt;math&gt;, satisfy the weakened
--   (i.e., ignoring &lt;math&gt;) multiplicative inverse law if and only
--   if &lt;math&gt; is prime.
--   
--   These do not exhaust the possibilities---not even close!---but it
--   should be enough to give a taste of what abstract algebra is all
--   about. You start with some set with defined operations (a pairing
--   known as a "structure") that you are familiar with, you distill that
--   structure down to its most basic and fundamental properties, and then
--   you look at what sorts of things satisfy those properties and what
--   those properties alone entail. This allows you to generalize familiar
--   structures to more abstract ideas---the original motivating structure
--   becomes just a special case of a more general property, and seemingly
--   disparate things suddenly become two special cases of a more general
--   idea.
--   
--   The laws I gave above define a ring; that is, any set (with the two
--   defined binary operations over it, as well as the two distinguished
--   elements) satisfying the above list of properties is known as a
--   <b>ring</b>. The laws are called the <b>ring axioms</b>. <b>Ring
--   theory</b> is the branch of math studying rings and how they relate to
--   each other and to other parts of math. Rings are not the only
--   algebraic structure; there are many, many more, and this package
--   defines a few of the more important ones as Haskell typeclasses, as
--   well as some instances of types as members of that typeclass. Each
--   module contains in its documentation an overview of that algebraic
--   structure and some interesting properties of them that make them worth
--   studying.
--   
--   Sadly, the laws are not yet enforced (as is typical with Haskell
--   typeclasses); only the "signature" of the structures are (the set(s),
--   the operation(s) defined over it/them, and the types of all objects
--   involved).
module Algebra

-- | A <tt>Group</tt> is a type <tt>G</tt> combined with an instance
--   declaration for the <a>Group</a> typeclass, whose minimally complete
--   (and in fact only possible) definition is of <tt>(((*) :: G -&gt; G
--   -&gt; G), ((id) :: G), (inv :: G -&gt; G))</tt> that satisfies the
--   following unchecked properties:
--   
--   <pre>
--   (x * y) * z == x * (y * z)
--   </pre>
--   
--   <pre>
--   (x * id == x) &amp;&amp; (id * x == x)
--   </pre>
--   
--   <pre>
--   (x * inv x == x) &amp;&amp; (inv x * x == x)
--   </pre>
--   
--   Note that the same type can be a group in multiple ways. This is a bit
--   annoying in Haskell, as it necessitates the use of <tt>type</tt>
--   wrappers to implement a class in different ways in the same scope.
class (Eq g) => Group g
(*) :: Group g => g -> g -> g
id :: Group g => g
inv :: Group g => g -> g

-- | Exponentiation, or repeated application of the group function "(*)".
--   Note that this is <i>not</i> a binary operation over a <a>Group</a>;
--   the first argument is a member of the group, but the second is just an
--   integer, specifying how many times to repeat the operation. Raising to
--   the zeroth power yields identity; raising to a negative power is the
--   corresponding positive power of the inverse.
(^) :: (Group grp) => grp -> Integer -> grp

-- | The <a>order</a> of an element of a group is the smallest positive
--   integer such that raising the group element to that power (see '(^)')
--   yields the identity, <a>id</a>---or positive infinity if no such
--   element exists. The latter case implies that this function may be (and
--   in fact often is) non-terminating. In finite groups (groups with
--   finitely many elements), however, it is a useful construct; the order
--   of any element in a fintie group is finite.
order :: (Group grp) => grp -> Integer
